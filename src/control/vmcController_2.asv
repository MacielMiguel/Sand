function vmcController_2()
%% ============================================
%  SAND Robot — Initial setup
% ============================================
clc; close all;

% Motors IDs
DXL_IDS = [1 2 3];  

% Registers addresses (AX-12, protocol 1.0)
ADDR_TORQUE_ENABLE    = 24;
ADDR_GOAL_POSITION    = 30;
ADDR_PRESENT_POSITION = 36;

TORQUE_ENABLE  = 1;
TORQUE_DISABLE = 0;

% Communication setup
PROTOCOL_VERSION = 1.0;
BAUDRATE         = 1000000;     
DEVICENAME       = 'COM5';      

% Result codes
COMM_SUCCESS = 0;

% === Library selection ===
if strcmp(computer, 'PCWIN')
    LIB_NAME = 'dxl_x86_c';
elseif strcmp(computer, 'PCWIN64')
    LIB_NAME = 'dxl_x64_c';
elseif strcmp(computer, 'GLNX86')
    LIB_NAME = 'libdxl_x86_c';
elseif strcmp(computer, 'GLNXA64')
    LIB_NAME = 'libdxl_x64_c';
elseif strcmp(computer, 'MACI64')
    LIB_NAME = 'libdxl_mac_c';
else
    error('Error: no recognition of OS.');
end

if ~libisloaded(LIB_NAME)
    fprintf('Charging library "%s"...\n', LIB_NAME);
    loadlibrary(LIB_NAME, 'dynamixel_sdk.h', ...
                'addheader','port_handler.h', ...
                'addheader','packet_handler.h');
end

% === Port handler setup ===
port_num = portHandler(DEVICENAME);
packetHandler();

% === onCleanup: garante reset da porta/biblioteca mesmo se der erro ===
cleanupObj = onCleanup(@() localCleanup(port_num, PROTOCOL_VERSION, ...
                                       DXL_IDS, ADDR_TORQUE_ENABLE, ...
                                       TORQUE_DISABLE, LIB_NAME));

% === Open serial port ===
fprintf('Open port %s...\n', DEVICENAME);
if openPort(port_num)
    fprintf('It was open succesfully!\n');
else
    error('Fail in openning port.');
end

% === Set baudrate ===
setBaudRate(port_num, BAUDRATE);

% === Torque activation for each motor ===
for id = DXL_IDS
    write1ByteTxRx(port_num, PROTOCOL_VERSION, id, ...
                   ADDR_TORQUE_ENABLE, TORQUE_ENABLE);

    dxl_comm_result = getLastTxRxResult(port_num, PROTOCOL_VERSION);
    dxl_error       = getLastRxPacketError(port_num, PROTOCOL_VERSION);

    if dxl_comm_result ~= COMM_SUCCESS
        error('[ID:%d] Error of communication: %s', ...
              id, getTxRxResult(PROTOCOL_VERSION, dxl_comm_result));
    elseif dxl_error ~= 0
        error('[ID:%d] Error of packet: %s', ...
              id, getRxPacketError(PROTOCOL_VERSION, dxl_error));
    end
    fprintf(' -> Motor ID %d conected and torque activated.\n', id);
end

ADDR_MOVING_SPEED = 32;

speedVal = 700; % ajuste: 100 lento, 400 médio, 700 rápido
for id = DXL_IDS
    write2ByteTxRx(port_num, PROTOCOL_VERSION, id, ADDR_MOVING_SPEED, speedVal);
end

fprintf('\n SETUP FINISHED \n\n');

%TIME_STEP = 1;
%dt        = TIME_STEP / 10;

fprintf("Starting controller...\n");

try
    %% === Geometry (Moteur 1 = Latéral, Moteurs 2&3 = 6-Barres) ===
    L1 = 0.04;
    L2 = 0.10; 
    L3 = 0.10; 
    
    % Angles offset (Attention à l'ordre !)
    % theta1 = Moteur Latéral (Abduction)
    % theta2 = Moteur Cuisse
    % theta3 = Moteur Bielle
    theta1_offset = 0.0; 
    theta2_offset = 0.0; 
    theta3_offset = 0.0; 
    
    %% === VMC parameters ===
    % Kvmc reste aligné sur les axes cartésiens [X, Y, Z]
    % 30 = Raideur X (Jambe), 30 = Raideur Y (Latéral), 40 = Raideur Z (Jambe)
    Kvmc = diag([30 30 40]); 
    Dvmc = diag([4  4  3]);
    tauMax = [10.0; 10.0; 10.0]; 
    
    %% === Ellipse ===
    a = 0.02; 
    b = 0.015; 
    T = 6.0;
    omega = 2*pi/T;
    
    %% === First reading ===
    q_read = readSensors(port_num, PROTOCOL_VERSION, DXL_IDS, ADDR_PRESENT_POSITION);     

    theta1 = q_read(1) + theta1_offset; % LATERAL
    theta2 = q_read(2) + theta2_offset; % JAMBE A
    theta3 = q_read(3) + theta3_offset; % JAMBE B

    q = [theta1; theta2; theta3];
    
    % --- FK Initiale ---
    % X et Z dépendent des moteurs 2 et 3
    % Y dépend du moteur 1
    % rho = L2*cos(theta2) + L3*cos(theta2+theta3);
    % z = -(L2*sin(theta2) + L3*sin(theta2+theta3));
    
    % x = L1*cos(theta1) + rho*sin(theta1);
    % y = L1*sin(theta1) - rho*cos(theta1);
    
    m = sqrt(L2^2 + L3^2 + 2*L2*L3*cos(theta3));
    x = L1*cos(theta1) - m*sin(theta1);
    y = L1*sin(theta1) + m*cos(theta1);
    z = L2*sin(theta2) + L3*sin(theta2 + theta3);

    chi = [x; y; z];

    chi_center = chi - [b; 0; 0];
    chi0 = chi_center; 
    
    fprintf("Initial pos = [%.3f %.3f %.3f]\n", chi);
    
    %% === State for derivatives ===
    q_prev  = q;
    dq_prev = [0;0;0];
    alpha_q = 1; 
    %t       = 0;
    
    %% === Live plot ===
    fig = figure('Name','6-Bar Leg – YZ','NumberTitle','off');
    hold on; grid on; axis equal;
    xlabel('Y [m]'); ylabel('Z [m]');
    title('Tracking YZ - Moteur 1 Latéral');

    tau_plot = linspace(0,T,400);
    chi_d_plot = zeros(3,numel(tau_plot));
    for k = 1:numel(tau_plot)
        chi_d_plot(:,k) = chi0 + [a*cos(omega*tau_plot(k)); 0; b*sin(omega*tau_plot(k))];
    end
    plot(chi_d_plot(1,:), chi_d_plot(3,:), '--');   % ideal ellipse
    h_real = plot(chi(1), chi(3), 'o-', 'Color', [1 0.5 0]);
    legend('show'); % Ajoute la légende pour distinguer les deux
        
    %% === Antes do loop (inicialização de tempo) ===
    t0     = tic;      % cronômetro do "tempo absoluto"
    t_last = tic;      % cronômetro para medir dt entre iterações
    
    % (opcional) alvo de frequência, ex: 10.000 Hz
    dt_target = 0.0001;
    
    %% === Principal loop ===
    while true
        % --- Tempo real ---
        t  = toc(t0);          % tempo absoluto desde o início (segundos)
        dt_meas = toc(t_last); % dt real desde a última iteração
        t_last = tic;          % reinicia medição de dt para a próxima iteração
    
        % Proteção: evita divisão por zero/valores absurdos
        if dt_meas <= 0
            dt_meas = 1e-3;
        end
    
        % READING SENSORS
        q_read = readSensors(port_num, PROTOCOL_VERSION, DXL_IDS, ADDR_PRESENT_POSITION);
    
        theta1 = q_read(1) + theta1_offset; % LATERAL
        theta2 = q_read(2) + theta2_offset; % JAMBE A
        theta3 = q_read(3) + theta3_offset; % JAMBE B
    
        q = [theta1; theta2; theta3];
    
        % --- Velocity (usa dt_meas medido) ---
        dq_raw  = (q - q_prev)/dt_meas;
        dq      = alpha_q*dq_raw + (1-alpha_q)*dq_prev;
        q_prev  = q;
        dq_prev = dq;
    
        % --- FK (Position Actuelle) ---
        %rho = L2*cos(theta2) + L3*cos(theta2+theta3);
        %z = -(L2*sin(theta2) + L3*sin(theta2+theta3));
        
        %x = L1*cos(theta1) + rho*sin(theta1);
        %y = L1*sin(theta1) - rho*cos(theta1);
        
        m = sqrt(L2^2 + L3^2 + 2*L2*L3*cos(theta3));
        x = L1*cos(theta1) - m*sin(theta1);
        y = L1*sin(theta1) + m*cos(theta1);
        z = L2*sin(theta2) + L3*sin(theta2 + theta3);

        chi = [x; y; z];

        % --- Jacobian ---
        % J11 = -L1*sin(theta1) + rho*cos(theta1);
        % J21 =  L1*cos(theta1) + rho*sin(theta1);
    
        % drho_dth2 = -L2*sin(theta2) - L3*sin(theta2+theta3);
        % drho_dth3 = -L3*sin(theta2+theta3);
    
        % J12 = sin(theta1)*drho_dth2;
        % J13 = sin(theta1)*drho_dth3;
    
        % J22 = -cos(theta1)*drho_dth2;
        % J23 = -cos(theta1)*drho_dth3;
    
        % J32 = -rho;
        % J33 = -L3*cos(theta2+theta3);
    
        % J = [ J11, J12, J13;
        %      J21, J22, J23;
        %       0, J32, J33 ];
    
        J = [ ...
            -L1*sin(theta1) - m*cos(theta1),  0,  (L2*L3*sin(theta3)*sin(theta1))/m; ...
             L1*cos(theta1) - m*sin(theta1),  0, -(L2*L3*sin(theta3)*cos(theta1))/m; ...
             0,  L2*cos(theta2) + L3*cos(theta2+theta3),  L3*cos(theta2+theta3) ...
        ];

        dchi = J * dq;
    
        % --- Desired trajectory (usa t absoluto real) ---
        chi_d  = chi0 + [a*cos(omega*t);        0; b*sin(omega*t)];
        dchi_d =       [-a*omega*sin(omega*t);  0; b*omega*cos(omega*t)];
    
        % --- Inputs VMC ---
        e  = chi_d  - chi;
        de = dchi_d - dchi;
    
        Fv = Kvmc*e + Dvmc*de;
    
        % --- Conversion Force -> Couple ---
        tau = J.' * Fv;
    
        % Saturation
        tau = max(min(tau, tauMax), -tauMax);
    
        % --- Writing to Motors ---
        writeMotors(port_num, PROTOCOL_VERSION, DXL_IDS, ...
                    ADDR_GOAL_POSITION, ADDR_PRESENT_POSITION, q_read, tau);
    
        % --- Update plot ---
        set(h_real, 'XData', [get(h_real,'XData') chi(1)], ...
                    'YData', [get(h_real,'YData') chi(3)]);
        drawnow("limitrate");
    
        % --- Debug ---
        fprintf("t=%.3f | dt=%.4f | LatTau=%.2f LegTau=[%.2f %.2f] | Y_err=%.3f\n", ...
                t, dt_meas, tau(1), tau(2), tau(3), e(2));
    
        % (opcional) limitar CPU sem usar isso como relógio:
        % pause(0.001);
    
        % (opcional) se quiser tentar manter ~dt_target, faça:
        slack = dt_target - dt_meas;
        if slack > 0, pause(slack); end
    end


catch ME
    fprintf('\n[vmcController] ERROR: %s\n', ME.message);
end

end 

% Subfunction to clean up the system in case of fail
function localCleanup(port_num, PROTOCOL_VERSION, DXL_IDS, ...
                      ADDR_TORQUE_ENABLE, TORQUE_DISABLE, LIB_NAME)

fprintf('\n[Cleanup] Releasing Dynamixel resources...\n');

% Desactivating the Torque
if ~isempty(DXL_IDS)
    for idc = DXL_IDS
        try
            write1ByteTxRx(port_num, PROTOCOL_VERSION, idc, ...
                           ADDR_TORQUE_ENABLE, TORQUE_DISABLE);
        catch
            
        end
    end
end

% Closes port
try
    closePort(port_num);
catch
end

% clean library
try
    if libisloaded(LIB_NAME)
        unloadlibrary(LIB_NAME);
    end
catch
end

fprintf('[Cleanup] Done. Port and library released.\n');

end
